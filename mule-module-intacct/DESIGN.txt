---++ Design guidelines for the Intacct Cloud connector

---+++ Introduction

Intacct's API is XML based. They provide two sets of DTDs. One for the 
requests, and one for the responses. All the requests (regardless of the API's
function that is being invoked) have the same boilerplate header. For example 
the API call for the get_invoice function looks something like:
---------------8<---------------------8<----------------------
     <?xml version="1.0" encoding="UTF-8"?>
     <!DOCTYPE request SYSTEM "intacct_request.v2.1.dtd">
     <request>
      <control>
       <senderid>intacct_dev</senderid>
       <password>babbage</password>
       <controlid>XML Sample</controlid>
      </control>
      <operation>
       <authentication>
        <login>
         <userid>xmluser</userid>
         <companyid>XML Sample</companyid>
         <password>abc123</password>
        </login>
       </authentication>
       <content>
         <function controlid="testControlId">
            <get_invoice key="XXXX"/>
         </function>
       </content>
      </operation>
     </request>
---------------8<---------------------8<----------------------


the /request/operation/content/function element is the boilerplate ends and 
starts the API function call. Not all the functions have simple arguments. 
On the contrary, most of the calls have complex data types. For example the 
listing the some accounts filtering and sorting by some criteria:


---------------8<---------------------8<----------------------
     ...
     <content>
      <function controlid="f4">
       <get_list object="glaccount">
        <filter>
         <logical logical_operator="or">
          <logical logical_operator="and">
           <expression>
            <field>accountno</field>
            <operator>&gt;</operator>
            <value>5000</value>
           </expression>
           <expression>
            <field>normalbalance</field>
            <operator>=</operator>
            <value>debit</value>
           </expression>
          </logical>
          <expression>
           <field>normalbalance</field>
           <operator>=</operator>
           <value>credit</value>
          </expression>
         </logical>
        </filter>
        <sorts>
         <sortfield order="asc">normalbalance</sortfield>
         <sortfield order="asc">title</sortfield>
        </sorts>
        <fields>
         <field>title</field>
         <field>normalbalance</field>
        </fields>
       </get_list>
      </function>
     </content>
---------------8<---------------------8<----------------------

Because of:
   * the protocol provides some data typing (DTDs) 
   * single end-point URL
   * all the API calls "looks similar"
   * the complexity (and powerful expression) of the operations

...we think that is good idea that the "Intacct Mule Connector" sticks to the 
Intacct's content/function syntax, instead of defining another type of XML 
like in the Salesforce or the Authorize.net connectors. So that was the 
approach we took. 
To ease the To ease the maintenance and minimize the coding 
and minimize the coding (170+ API calls) this is the approach we took:

   1. We dowloaded the DTDs from http://developer.intacct.com. Saved for 
      future record in 
         src/main/resources/META-INF/dtds/request/ 
      and 
         src/main/resources/META-INF/dtds/response/
   2. We had to fix some small DTDs typos :^O
   3. With JAXB xjc.sh we generated the java classes that represent the schema
      (although DTD support is "experimental", works better than trang's 
      conversion from dtd to xsd) for the request and the response 
      (classes are located at org.mule.module.intacct.schema.request and 
      org.mule.module.intacct.schema.response packages). This step could 
      eventually be automated with a maven jaxb plugin. It is important to 
      use two separate packages because request and response have some 
      types named the same with different attributes.
   4. With the classes generated and compiled (mvn package) we used JAXB's 
      schemagen 
        schemagen.sh -cp . org.mule.module.intacct.schema.request.Function
      to generate the XSD from the function element. This will be used as a 
      part of spring handler's XSD.(bottom of mule-intacct.xsd)
   5. We added to the mule-intacct.xsd file all the mule's things (imports, the
      config element, and a message processor called operation used to send API
      calls).
   6. We wrote the IntacctCloudConnector class  that implements the config 
      element and the 
         Response operation(final Function function)
      Here we are using a IntacctFacade interface to abstract the actual 
      connection to the endpoint.  The idea is that in the future the 
      implementation used by the IntacctCloudConnector could be configured
      so it is easy to test.
   7. We wrote the IntacctNamespaceHandler to register the config and the 
      operation elements, and we write some extensions to:
      * ChildDefinitionParser: to allow having JAXB DTO's to the connector 
        functions.
      * InvokerMessageProcessor: to allow message expression resolution to all
        the DTOs elements (similar to what it happens with sfdc:sObject / sfdc:
        field in the sales force connector).

With this aproach, all the API calls are available not just (the get_invoice).

What is missing right now is some tests, and posting the XML to the endpoint
(we couldn get an accout yet); but that is the easy part :)

If you want to try to configure the connector (for example extending the 
example file src/test/resources/intacct-namespace-config.xml) with Eclipse; 
then we recommend to configure Eclipse so it can find the xsd file 
(as it is not published over HTTP). For this, go to:  
   1. Window / Preferences. XML / XML / XML Catalog. 
   2. Press "Add..." button / Workspace... 
   3. select mule-intacct.xsd from the intacct project, 
   4. change Key Type to "Schema Location".

