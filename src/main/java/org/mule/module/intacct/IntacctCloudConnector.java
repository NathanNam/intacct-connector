/**
 * Mule Intacct Cloud Connector
 *
 * (c) 2003-2012 MuleSoft, Inc. This software is protected under international
 * copyright law. All use of this software is subject to MuleSoft's Master
 * Subscription Agreement (or other Terms of Service) separately entered
 * into between you and MuleSoft. If such an agreement is not in
 * place, you may not use the software.
 */

/**
 * This file was automatically generated by the Mule Development Kit
 */
package org.mule.module.intacct;

import static org.apache.commons.collections.CollectionUtils.isNotEmpty;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import javax.annotation.PostConstruct;
import javax.xml.bind.JAXBException;

import org.apache.commons.lang.Validate;
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Module;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.display.FriendlyName;
import org.mule.api.annotations.display.Password;
import org.mule.api.annotations.display.Placement;
import org.mule.api.annotations.param.Optional;
import org.mule.module.intacct.exception.IntacctException;
import org.mule.module.intacct.impl.JerseySslIntacctFacade;
import org.mule.module.intacct.response.IntacctResponseWrapper;
import org.mule.module.intacct.schema.request.CreateAradjustment;
import org.mule.module.intacct.schema.request.CreateInvoice;
import org.mule.module.intacct.schema.request.CreateInvoicebatch;
import org.mule.module.intacct.schema.request.CreateSotransaction;
import org.mule.module.intacct.schema.request.Customfield;
import org.mule.module.intacct.schema.request.Field;
import org.mule.module.intacct.schema.request.Filter;
import org.mule.module.intacct.schema.request.Function;
import org.mule.module.intacct.schema.request.Get;
import org.mule.module.intacct.schema.request.GetList;
import org.mule.module.intacct.schema.request.Lineitem;
import org.mule.module.intacct.schema.request.Request;
import org.mule.module.intacct.schema.request.Sortfield;
import org.mule.module.intacct.schema.request.Sotransitem;
import org.mule.module.intacct.schema.request.Subtotal;
import org.mule.module.intacct.schema.response.Response;
import org.mule.module.intacct.utils.MapBuilder;


/**
 * Cloud Connector Facade for <a href="http://us.intacct.com/">Intacct</a>
 * @author jcodagnone
 */
@Module(name = "intacct", friendlyName="Intacct")
public class IntacctCloudConnector
{
    /**
     * Intacct-registered Web Services username.
     */
    @Configurable
    private String senderId;

    /**
     * Registered Web Services password
     */
    @Configurable
    @Password
    private String controlPassword;

    /**
     * Used by the sender to match a request to its response. This is especially
     * useful during asynchronous requests. The following illustrates the syntax
     * for a request element.
     */
    @Configurable
    private String controlId;

    /**
     * The Intacct system guarantees transaction idempotence through the use of the uniqueId.
     * The default setting for the uniqueId element is "true" with all lower-case characters.
     * If the uniqueId element value is set to "true", the designated function will be
     * performed only once. Before a function is executed, the controlId attribute of the
     * function tag is checked for uniqueness. If a function is submitted twice under the
     * same controlId and sender, the function will not be re-executed. However, a failed
     * request may be re-submitted under the same controlId and sender.

     */
    @Configurable
    private String uniqueId;

    /**
     * The login information specifies the user's Intacct identity.
     * This is the same information you see when you log onto the Intacct system.
     */
    @Configurable
    private String userId;

    /**
     * The login information specifies the user's Intacct password.
     * This is the same information you see when you log onto the Intacct system.

     */
    @Configurable
    @Password
    private String userPassword;

    /**
     * The login information specifies the user's Intacct company.
     * This is the same information you see when you log onto the Intacct system.
     */
    @Configurable
    private String companyId;

    /**
     * Intacct Client implementation. By default: {@link JerseySslIntacctFacade}
     */
    @Configurable
    @Optional
    private IntacctFacade intacctImplementation;

    /**
     * The login information specifies the user's Intacct client id.
     * This is the same information you see when you log onto the Intacct system.
     */
    @Configurable
    @Optional
    protected String clientId;

    /**
     * The login information specifies the user's Intacct location id.
     * This is the same information you see when you log onto the Intacct system.
     */
    @Configurable
    @Optional
    protected String locationId;

    private IntacctMapObjectMapper mom =  new IntacctMapObjectMapper();

    private RequestFactory requestFactory;


    private static final String URL = "https://www.intacct.com/ia/xml/xmlgw.phtml";

    /**
     * Given the function we create the request with the parameters for default given in the config
     * @deprecated use {@link #execute(CommandType, List)} instead
     *
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:operation}
     *
     * @param function function
     * @return {@Response}
     * @throws JAXBException if the marshalling failed
     */
    @Deprecated
    @Processor
    public IntacctResponseWrapper operation(@Placement(group = "Function") final Map<String, Object> function) throws JAXBException
    {
        return sendRequest(requestFactory.createRequestFromFunction(mom.toObject(Function.class, function)));
    }


    /**
     * Batch executes a list of commands of the given CommandType.
     * <p>
     * This processor, it's the equivalent of making an {@link #operation(Map)} (deprecated)
     * of a function with all its elements of the same Commandtype.
     *
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:execute1}
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:execute2}
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:execute3}
     *
     * @param functionControlId String. Is used by the sender to match a request to
     *                          its response for the function that will be created
     *                          for this operation. This is especially useful during
     *                          asynchronous requests.
     * @param type the type of commands to execute
     * @param commands the commands list
     * @throws JAXBException if the marshalling failed
     * @return the {@link Response}
     */
    @Processor
    public IntacctResponseWrapper execute(String functionControlId, final CommandType type, @Placement(group = "Commands") final List<Map<String, Object>> commands) throws JAXBException
    {
        Map<String, Object> function = mom.wrapList("cmd", commands, type.getRequestType());
        function.put("controlid", functionControlId);

        return operation(function);
    }


    /**
     * Creates an {@link org.mule.module.intacct.schema.response.Invoice}
     * <p>
     * An invoice is a document within the Intacct system. The invoice represents a
     * transaction between the company and a customer.
     * <p>
     * Documentation: <a href="http://developer.intacct.com/wiki/invoice">Invoice<a>
     * <p>
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:create-invoice}
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:create-invoice2}
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:create-invoice3}
     *
     * @param functionControlId String. Is used by the sender to match a request to
     *                          its response for the function that will be created
     *                          for this operation. This is especially useful during
     *                          asynchronous requests.
     * @param customerId Customer identification code.
     * @param dateCreated Date when the invoice has been created.
     * @param datePosted Date when the invoice has been posted.
     * @param dateDue Date when the invoice expires.
     * @param termName The term name.
     * @param batchKey The batch key code.
     * @param invoiceNo Invoice number.
     * @param poNumber The poNumber.
     * @param description A description of the invoice.
     * @param externalId the external Id.
     * @param billToContactType The only kind of element that will be listed in the billTo
     *                          parameter. Contact or ContactName.
     * @param billToContacts List of contacts to bill.
     * @param shipToContactType The only kind of element that will be listed in the shipTo
     *                          parameter. Contact or ContactName.
     * @param shipToContacts List of contacts to ship.
     * @param basecurr Base currency.
     * @param currency The currency.
     * @param exchType The only kind of element that will be listed in the
     *                 exchRateDateOrExchRateTypeOrExchRate parameter. ExchRateDate,
     *                 ExchRateType or ExchRate.
     * @param exchRateDatesOrExchRateTypesOrExchRates List of exchanges.
     * @param nogl The General Ledger number.
     * @param customFields List of custom fields.
     * @param invoiceItems List of invoice items.
     * @return A {@link Response}
     * @throws JAXBException if the marshalling failed
     */
    @Processor
    public IntacctResponseWrapper createInvoice(String functionControlId,
                                  String customerId,
                                  @Placement(group = "Date Created") Map<String, Object> dateCreated,
                                  @Placement(group = "Date Posted") @Optional Map<String, Object> datePosted,
                                  @Placement(group = "Date Due") @Optional Map<String, Object> dateDue,
                                  @Optional String termName,
                                  @Optional String batchKey,
                                  @Optional String invoiceNo,
                                  @Optional String poNumber,
                                  @Optional String description,
                                  @Optional String externalId,
                                  @Optional ContactType billToContactType,
                                  @Placement(group = "Bill To Contacts")  @Optional List<Map<String, Object>> billToContacts,
                                  @Optional ContactType shipToContactType,
                                  @Placement(group = "Ship To Contacts") @Optional List<Map<String, Object>> shipToContacts,
                                  @Optional String basecurr,
                                  @Optional String currency,
                                  @Optional ExchType exchType,
                                  @Placement(group = "Exchange Rates") @Optional List<Map<String, Object>> exchRateDatesOrExchRateTypesOrExchRates,
                                  @Optional String nogl,
                                  @Placement(group = "Custom Fields") @Optional List<Map<String, Object>> customFields,
                                  @Placement(group = "Invoice Items") List<Map<String, Object>> invoiceItems) throws JAXBException
    {
        Validate.notEmpty(dateCreated);
        Object invoiceItemsAux = nullifyEmptyListWrapper("lineitem", invoiceItems, Lineitem.class);
        Validate.notNull(invoiceItemsAux);

        List<Object> exchRateDateOrExchRateTypeOrExchRateAux = new ArrayList<Object>();
        if (exchRateDatesOrExchRateTypesOrExchRates != null && exchType != null)
        {
            for (Map<String, Object> exch : exchRateDatesOrExchRateTypesOrExchRates)
            {
                exchRateDateOrExchRateTypeOrExchRateAux.add(mom.toObject(exchType.getRequestType(), exch));
            }
        }

        CreateInvoice command = mom.toObject(CreateInvoice.class,
            new MapBuilder().with("customerid", fromSingleValue(customerId))
                            .with("datecreated", dateCreated)
                            .with("dateposted", datePosted)
                            .with("datedue", dateDue)
                            .with("termname", fromSingleValue(termName))
                            .with("batchkey", fromSingleValue(batchKey))
                            .with("invoiceno", invoiceNo)
                            .with("ponumber", poNumber)
                            .with("description", description)
                            .with("externalid", externalId)
                            .with("shipto", nullifyEmptyListWrapper("contactOrContactname", shipToContacts, nullifyEnumType(shipToContactType)))
                            .with("billto", nullifyEmptyListWrapper("contactOrContactname", billToContacts, nullifyEnumType(billToContactType)))
                            .with("basecurr", basecurr)
                            .with("currency", currency)
                            .with("exchratedateOrExchratetypeOrExchrate", coalesceList(exchRateDateOrExchRateTypeOrExchRateAux))
                            .with("nogl", nogl)
                            .with("customfields", nullifyEmptyListWrapper("customfield", customFields, Customfield.class))
                            .with("invoiceitems", invoiceItemsAux)
                            .build());

        return sendRequest(functionControlId, command);
    }

    /**
     * Creates an {@link org.mule.module.intacct.schema.response.Invoicebatch}
     * <p>
     * An invoice batch is an entity that groups invoices. Every invoice in the Intacct
     * system must be assigned to a batch.
     * <p>
     * Documentation: <a href="http://developer.intacct.com/wiki/invoice-batch">Invoicebatch<a>
     * <p>
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:create-invoice-batch}
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:create-invoice-batch2}
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:create-invoice-batch3}
     *
     * @param functionControlId String. Is used by the sender to match a request to
     *                          its response for the function that will be created
     *                          for this operation. This is especially useful during
     *                          asynchronous requests.
     * @param batchTitle The title that is given to this batch of {@link CreateInvoice}s.
     * @param dateCreated The date when the invoices have been created.
     * @param createInvoices List of {@link CreateInvoice}s.
     * @return A {@link Response}.
     * @throws JAXBException if the marshalling failed
     */
    @Processor
    public IntacctResponseWrapper createInvoiceBatch(String functionControlId,
                                       String batchTitle,
                                       @Placement(group = "Date Created") @Optional Map<String, Object> dateCreated,
                                       @Placement(group = "Create Invoices") @Optional List<Map<String, Object>> createInvoices
                                       ) throws JAXBException
    {
        List<CreateInvoice> createInvoiceList = new ArrayList<CreateInvoice>();
        if (createInvoices != null)
        {
            for (Map<String, Object> invoice : createInvoices)
            {
                createInvoiceList.add(mom.toObject(CreateInvoice.class, invoice));
            }
        }

        CreateInvoicebatch command = mom.toObject(CreateInvoicebatch.class,
            new MapBuilder()
                            .with("batchtitle", batchTitle)
                            .with("datecreated", dateCreated)
                            .with("createInvoice", coalesceList(createInvoiceList))
                            .build()
            );

        return sendRequest(functionControlId, command);
    }

    /**
     * Creates an {@link org.mule.module.intacct.schema.response.Aradjustment}
     * <p>
     * An AR Adjustment is a document within the Intacct system. The AR Adjustment represents
     * an adjustment to the customer's account, with or without reference to an existing
     * invoice. Generally, the AR Adjustment is an internal document, not an invoice, and
     * therefore does not have a due date.
     * <p>
     * Documentation: <a href="http://developer.intacct.com/wiki/ar-adjustment">Aradjustment<a>
     * <p>
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:create-a-r-adjustment}
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:create-a-r-adjustment2}
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:create-a-r-adjustment3}
     *
     * @param functionControlId String. Is used by the sender to match a request to
     *                          its response for the function that will be created
     *                          for this operation. This is especially useful during
     *                          asynchronous requests.
     * @param customerId Customer identification code.
     * @param dateCreated Date when the adjustment to the customer's account has been made.
     * @param datePosted Date when the adjustment to the customer's account has been posted.
     * @param batchKey The batch key code. If the desired batch already exists, it can be
     *                 specified using this field. This approach gives you the flexibility
     *                 to easily assign different batches to documents posted within a
     *                 single request.
     * @param adjustmentNo Adjustment number.
     * @param invoiceNo Invoice number.
     * @param description A description of the adjustment.
     * @param externalId The external Id.
     * @param basecurr Base currency.
     * @param currency The currency.
     * @param exchType The kind of elements that will be listed in the
     *                 exchRateDateOrExchRateTypeOrExchRate parameter. ExchRateDate,
     *                 ExchRateType or ExchRate.
     * @param exchRateDatesOrExchRateTypesOrExchRates List of exchanges.
     * @param nogl The General Ledger number.
     * @param aRAdjustmentItems List of AR adjustment items.
     * @return A{@link Response}.
     * @throws JAXBException if the marshalling failed
     */
    @Processor(friendlyName = "Create AR adjustment")
    public IntacctResponseWrapper createARAdjustment(String functionControlId,
                                       String customerId,
                                       @Placement(group = "Date Created") Map<String, Object> dateCreated,
                                       @Placement(group = "Date Posted") @Optional Map<String, Object> datePosted,
                                       @Optional String batchKey,
                                       @Optional String adjustmentNo,
                                       @Optional String invoiceNo,
                                       @Optional String description,
                                       @Optional String externalId,
                                       @Optional String basecurr,
                                       @Optional String currency,
                                       @Optional ExchType exchType,
                                       @Placement(group = "Exchange Rates") @Optional List<Map<String, Object>> exchRateDatesOrExchRateTypesOrExchRates,
                                       @Optional String nogl,
                                       @Placement(group = "AR Adjustment Items") @FriendlyName("AR Adjustment Items") List<Map<String, Object>> aRAdjustmentItems
                                       ) throws JAXBException
    {
        Validate.notEmpty(dateCreated);
        Object arAdjustmentItemsAux = nullifyEmptyListWrapper("lineitem", aRAdjustmentItems, Lineitem.class);
        Validate.notNull(arAdjustmentItemsAux);

        List<Object> exchRateDateOrExchRateTypeOrExchRateAux = new ArrayList<Object>();
        if (exchRateDatesOrExchRateTypesOrExchRates != null && exchType != null)
        {
            for (Map<String, Object> exch : exchRateDatesOrExchRateTypesOrExchRates)
            {
                exchRateDateOrExchRateTypeOrExchRateAux.add(mom.toObject(exchType.getRequestType(), exch));
            }
        }
        CreateAradjustment command = mom.toObject(CreateAradjustment.class,
            new MapBuilder().with("customerid", fromSingleValue(customerId))
                            .with("datecreated", dateCreated)
                            .with("dateposted", datePosted)
                            .with("batchkey", fromSingleValue(batchKey))
                            .with("invoiceno", invoiceNo)
                            .with("description", description)
                            .with("externalid", externalId)
                            .with("basecurr", basecurr)
                            .with("currency", currency)
                            .with("exchratedateOrExchratetypeOrExchrate", coalesceList(exchRateDateOrExchRateTypeOrExchRateAux))
                            .with("nogl", nogl)
                            .with("aradjustmentitems", arAdjustmentItemsAux)
                            .with("adjustmentno", adjustmentNo)
                            .build()
            );

        return sendRequest(functionControlId, command);
    }


    /**
     * Creates an {@link org.mule.module.intacct.schema.response.Sotransaction}
     * <p>
     * A SOTransaction represents any transactional document created in the Order
     * Entry application. Each document in the Order Entry application is user definable;
     * there are no statically defined document types. When querying SOTransactions, it
     * may be useful to filter the query by the transactiontype field.
     * <p>
     * Documentation: <a href="http://developer.intacct.com/wiki/sotransaction">Sotransaction<a>
     * <p>
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:create-s-o-transaction}
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:create-s-o-transaction2}
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:create-s-o-transaction3}
     *
     * @param functionControlId String. Is used by the sender to match a request to
     *                          its response for the function that will be created
     *                          for this operation. This is especially useful during
     *                          asynchronous requests.
     * @param transactionType the transactionType
     * @param dateCreated Date when the SO Transaction has been made.
     * @param createdFrom From where it was created.
     * @param customerId Customer identification code.
     * @param documentNo Document number.
     * @param referenceNo Reference number.
     * @param termName The term name.
     * @param dateDue Date when the invoice expires.
     * @param message The message.
     * @param shippingMethod The shipping method.
     * @param billToContactType The only kind of element that will be listed in
     *                          the billTo parameter. Contact or ContactName.
     * @param billToContacts List of contacts to bill.
     * @param shipToContactType The only kind of element that will be listed in
     *                          the shipTo parameter. Contact or ContactName.
     * @param shipToContacts List of contacts to ship.
     * @param externalId The external Id.
     * @param basecurr Base currency.
     * @param currency The currency.
     * @param exchType The only kind of element that will be listed in the
     *                 exchRateDateOrExchRateTypeOrExchRate parameter. ExchRateDate,
     *                 ExchRateType or ExchRate.
     * @param exchRateDatesOrExchRateTypesOrExchRates List of exchanges.
     * @param vsoePriceList The vsoe (Vendor Specific Objective Evidence) price list.
     * @param customFields List of custom fields.
     * @param sOTransItems List of SO transactions items.
     * @param subTotals List of sub-totals.
     * @return A {@link Response}.
     * @throws JAXBException if the marshalling failed
     */
    @Processor(friendlyName = "Create SO transaction")
    public IntacctResponseWrapper createSOTransaction(String functionControlId,
                                        String transactionType,
                                        @Placement(group = "Date Created") Map<String, Object> dateCreated,
                                        @Optional String createdFrom,
                                        String customerId,
                                        @Optional String documentNo,
                                        @Optional String referenceNo,
                                        @Optional String termName,
                                        @Placement(group = "Date Due") @Optional Map<String, Object> dateDue,
                                        @Optional String message,
                                        @Optional String shippingMethod,
                                        @Optional ContactType billToContactType,
                                        @Placement(group = "Bill To Contacts") @Optional List<Map<String, Object>> billToContacts,
                                        @Optional ContactType shipToContactType,
                                        @Placement(group = "Ship To Contacts") @Optional List<Map<String, Object>> shipToContacts,
                                        @Optional String externalId,
                                        @Optional String basecurr,
                                        @Optional String currency,
                                        @Optional ExchType exchType,
                                        @Placement(group = "Exchange Rates") @Optional List<Map<String, Object>> exchRateDatesOrExchRateTypesOrExchRates,
                                        @Optional String vsoePriceList,
                                        @Placement(group = "Custom Fields") @Optional List<Map<String, Object>> customFields,
                                        @Placement(group = "SO Transaction Items") List<Map<String, Object>> sOTransItems,
                                        @Placement(group = "SubTotals") @Optional List<Map<String, Object>> subTotals
                                        ) throws JAXBException
    {
        Validate.notEmpty(dateCreated);
        Object soTransItemsAux = nullifyEmptyListWrapper("sotransitem", sOTransItems, Sotransitem.class);
        Validate.notNull(soTransItemsAux);

        List<Object> exchRateDateOrExchRateTypeOrExchRateAux = new ArrayList<Object>();
        if (exchRateDatesOrExchRateTypesOrExchRates != null && exchType != null)
        {
            for (Map<String, Object> exch : exchRateDatesOrExchRateTypesOrExchRates)
            {
                exchRateDateOrExchRateTypeOrExchRateAux.add(mom.toObject(exchType.getRequestType(), exch));
            }
        }

        CreateSotransaction command = mom.toObject(CreateSotransaction.class,
            new MapBuilder().with("transactiontype", transactionType)
                            .with("datecreated", dateCreated)
                            .with("createdfrom", createdFrom)
                            .with("customerid", fromSingleValue(customerId))
                            .with("documentno", documentNo)
                            .with("referenceno", referenceNo)
                            .with("termname", fromSingleValue(termName))
                            .with("datedue", dateDue)
                            .with("message", message)
                            .with("shippingmethod", shippingMethod)
                            .with("shipto", nullifyEmptyListWrapper("contactOrContactname", shipToContacts, nullifyEnumType(shipToContactType)))
                            .with("billto", nullifyEmptyListWrapper("contactOrContactname", billToContacts, nullifyEnumType(billToContactType)))
                            .with("externalid", externalId)
                            .with("basecurr", basecurr)
                            .with("currency", currency)
                            .with("exchratedateOrExchratetypeOrExchrate", coalesceList(exchRateDateOrExchRateTypeOrExchRateAux))
                            .with("vsoepricelist", vsoePriceList)
                            .with("customfields", nullifyEmptyListWrapper("customfield", customFields, Customfield.class))
                            .with("sotransitems", soTransItemsAux)
                            .with("subtotals", nullifyEmptyListWrapper("subtotal", subTotals, Subtotal.class))
                            .build()
            );

        return sendRequest(functionControlId, command);
    }

    protected Map<String, Object> fromSingleValue(final Object value)
    {
        return value == null ? null : Collections.singletonMap("value", value);
    }

    /**
     * Allows you to retrieve a list object with optional filter and/or sort specifications.
     * Filters can be simple or complex with logical groupings for AND and OR filtering.
     * <p>
     * Documentation: <a href="http://developer.intacct.com/wiki/get-list">getList<a>
     * <p>
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:get-list}
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:get-list2}
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:get-list3}
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:get-list4}
     *
     * @param functionControlId String. Is used by the sender to match a request to
     *                          its response for the function that will be created
     *                          for this operation. This is especially useful during
     *                          asynchronous requests.
     * @param obj String. The object on which to perform the query. <p>
     *            A list of valid objects is provided:<p>
     *            accountgroup, adjjournal, apaccountlabel, apadjustment, apadjustmentbatch,
     *            appayment, appaymentrequest, apterm, araccountlabel, aradjustment,
     *            aradjustmentbatch, arpayment, arpaymentbatch, arterm, artransactiondef,
     *            bankaccount, bill, billbatch, class, company_info, contact, contacttaxgroup,
     *            csnhistory, custglgroup, customer, customerachinfo, customerbankaccount,
     *            customerchargecard, customerppackage, department, employee, expensereport,
     *            expensereportbatch, expensetypes, glaccount, glbudget, glbudgetitem,
     *            glentry, gltransaction, icitem, ictotal, ictransaction, ictransactiondef,
     *            invoice, invoicebatch, itemglgroup, itemtaxgroup, journal, location,
     *            locationentity, locationgroup, popricelist, potransaction, potransactiondef,
     *            pricelistitem, productline, project, renewalmacro, reportingperiod,
     *            revrecschedule, revrecscheduleentry, revrectemplate, smarteventlog,
     *            sopricelist, sotransaction, sotransactiondef, statglaccount, statjournal,
     *            stkittransaction, subscription, taxdetail, taxschedule, taxscheduledetail,
     *            taxschedulemap, territory, trxcurrencies, uom, vendglgroup, vendor,
     *            vsoeitempricelist, vsoepricelist, warehouse.
     * @param start Optionl. During a list query you can specify the start record of the
     *              list of objects to return to increase performance. This attribute defaults
     *              to zero.
     * @param maxItems Optional. During a list query, you can specify the maximum number of
     *                 objects to return to increase performance. By combining this with the
     *                 Start attribute above you can loop through the objects in groups for
     *                 better performance.
     * @param showPrivate Optional. In Multi-entity Shared implementations, some objects may
     *                    be owned by a subsidiary entity, but are visible at the root. If
     *                    showprivate is set to "true", the getlist method will return all
     *                    records visible in the current multi-entity context. If showprivate
     *                    is left unset or is "false", getlist will only return those records
     *                    owned by the current multi-entity context.
     * @param filters Optional. A collection of filtering expressions to apply to the query.
     * @param sorts Optional. A collection of fields to sort by.
     * @param fields Optional. A collection of fields to retrieve in the query. The fields
     *               will be returned in the order requested. If the request does not include
     *               a fields element, the web service will return the default set of fields.
     * @return {@link Response}
     * @throws JAXBException if the marshalling failed
     */
    @Processor
    public IntacctResponseWrapper getList(String functionControlId,
                            String obj,
                            @Optional String start,
                            @Optional String maxItems,
                            @Optional String showPrivate,
                            @Placement(group = "Filters") @Optional List<Object> filters,
                            @Placement(group = "Sorters") @Optional List<Map<String, Object>> sorts,
                            @Placement(group = "Fields") @Optional List<Map<String, Object>> fields
                            ) throws JAXBException
    {
        
        MapBuilder builder = new MapBuilder().with("object", obj)
                        .with("start", start)
                        .with("maxitems", maxItems)
                        .with("showprivate", showPrivate)
                        .with("sorts", nullifyEmptyListWrapper("sortfield", sorts, Sortfield.class))
                        .with("fields", nullifyEmptyListWrapper("field", fields, Field.class));

        
        if (isNotEmpty(filters))
        {
            Filter filter = new Filter();
            filter.getLogicalOrExpression().addAll(filters);
            builder.with("filter", filter);
        }
            
        
        GetList command = mom.toObject(GetList.class, builder.build());

        return sendRequest(functionControlId, command);
    }


    /**
     * Allows you to retrieve all of the information about a single instance of an
     * Intacct object.
     * <p>
     * Additional options for manipulating the return fields allow you to retrieve
     * only the information that you need.
     * <p>
     * Documentation: <a href="http://developer.intacct.com/wiki/get">get<a>
     * <p>
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:get}
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:get2}
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:get3}
     *
     * @param functionControlId String. Is used by the sender to match a request to
     *                          its response for the function that will be created
     *                          for this operation. This is especially useful during
     *                          asynchronous requests.
     * @param obj String. The object on which to perform the query. <p>
     *            A list of valid objects is provided:<p>
     *            accountgroup, apaccountlabel, appaymentrequest, apterm, araccountlabel,
     *            arterm, bankaccount, bill, class, company_info, contact, csnhistory,
     *            customer, customerachinfo, customerbankaccount, customerchargecard,
     *            department, employee, expensetypes, glaccount, icitem, ictransaction,
     *            invoice, journal, location, locationentity, locationgroup, popricelist,
     *            potransaction, pricelistitem, productline, project, recurbill,
     *            recurinvoice, renewalmacro, reportingperiod, revrecschedule,
     *            revrecscheduleentry, sopricelist, sotransaction, statglaccount,
     *            stkittransaction, subscription, taxdetail, taxschedule, taxscheduledetail,
     *            taxschedulemap, territory, trxcurrencies, vendor, vsoepricelist, warehouse.
     * @param key The unique ID or key of the object instance to be retrieved.
     * @param externalKey Optional. Every object in the Intacct system is allowed to have an
     *                    External ID, which allows users to assign a unique ID outside of
     *                    the Intacct system. For example, if a partner application has its
     *                    own numbering scheme for bills, during bill creation each individual
     *                    bill can be assigned an External ID which would identify it in the
     *                    partner system. Later on, while using the Get and Delete functions
     *                    of the Intacct Gateway, the partner can then specify the External ID
     *                    rather than the Intacct ID. This way, the partner is not required to
     *                    store the Intacct ID of each object created in the Intacct system.
     * @param fields Optional. A collection of Maps that represents fields to retrieve in the
     *               query. If the request does not include a fields element, the gateway will
     *               return the default set of fields, including custom fields for any
     *               objects that have them.
     * @return {@link Response}
     *
     * @throws JAXBException if the marshalling failed
     */
    @Processor
    public IntacctResponseWrapper get(String functionControlId,
                        String obj,
                        String key,
                        @Optional String externalKey,
                        @Placement(group = "Fields") @Optional List<Map<String, Object>> fields
                        ) throws JAXBException
    {
        Get command = mom.toObject(Get.class,
            new MapBuilder().with("object", obj)
                            .with("key", key)
                            .with("externalkey", externalKey)
                            .with("fields", nullifyEmptyListWrapper("field", fields, Field.class))
                            .build()
            );

        return sendRequest(functionControlId, command);
    }

    protected IntacctResponseWrapper sendRequest(String functionControlId, Object command) throws JAXBException
    {
        return sendRequest(requestFactory.createRequestFromCommand(functionControlId, command));
    }

    public IntacctResponseWrapper sendRequest(final Request request) throws JAXBException
    {
        try
        {
            return intacctImplementation.executeOperation(request);
        }
        // Here we catch everything and we wrap it in our domain exception
        catch (Throwable ex)
        {
            throw new IntacctException("There was an error sending the request to the server."
                                       + " Please check the cause for further information", ex);
        }

    }

    /**
     * Reconoce la operacion con valores default setteados en el config
     *
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:operation-with-request}
     * {@sample.xml ../../../doc/mule-module-intacct.xml.sample intacct:operation-with-request2}
     *
     * @param request The {@link Request}
     * @return {@link Response}
     * @throws JAXBException if the marshalling failed
     */
    @Processor
    public IntacctResponseWrapper operationWithRequest(final Request request) throws JAXBException
    {
        return sendRequest(request);
    }

    @PostConstruct
    public void init()
    {
        if (intacctImplementation == null )
        {
            intacctImplementation = new JerseySslIntacctFacade(URL);
        }
        requestFactory = new RequestFactory(senderId, controlPassword, controlId, uniqueId, userId,
            userPassword, companyId, clientId, locationId);
    }



    /**
     * Returns the senderId.
     *
     * @return  with the senderId.
     */
    public String getSenderId()
    {
        return senderId;
    }

    /**
     * Sets the senderId.
     *
     * @param senderId  with the senderId.
     */

    public void setSenderId(String senderId)
    {
        this.senderId = senderId;
    }

    /**
     * Returns the controlPassword.
     *
     * @return  with the controlPassword.
     */
    public String getControlPassword()
    {
        return controlPassword;
    }

    /**
     * Sets the controlPassword.
     *
     * @param controlPassword  with the controlPassword.
     */

    public void setControlPassword(String controlPassword)
    {
        this.controlPassword = controlPassword;
    }

    /**
     * Returns the controlId.
     *
     * @return  with the controlId.
     */

    public String getControlId()
    {
        return controlId;
    }

    /**
     * Sets the controlId.
     *
     * @param controlId  with the controlId.
     */

    public void setControlId(String controlId)
    {
        this.controlId = controlId;
    }

    /**
     * Returns the uniqueId.
     *
     * @return  with the uniqueId.
     */

    public String getUniqueId()
    {
        return uniqueId;
    }

    /**
     * Sets the uniqueId.
     *
     * @param uniqueId  with the uniqueId.
     */

    public void setUniqueId(String uniqueId)
    {
        this.uniqueId = uniqueId;
    }

    /**
     * Returns the userId.
     *
     * @return  with the userId.
     */

    public String getUserId()
    {
        return userId;
    }

    /**
     * Sets the userId.
     *
     * @param userId  with the userId.
     */

    public void setUserId(String userId)
    {
        this.userId = userId;
    }

    /**
     * Returns the userPassword.
     *
     * @return  with the userPassword.
     */

    public String getUserPassword()
    {
        return userPassword;
    }

    /**
     * Sets the userPassword.
     *
     * @param userPassword  with the userPassword.
     */

    public void setUserPassword(String userPassword)
    {
        this.userPassword = userPassword;
    }

    /**
     * Returns the companyId.
     *
     * @return  with the companyId.
     */

    public String getCompanyId()
    {
        return companyId;
    }

    /**
     * Sets the companyId.
     *
     * @param companyId  with the companyId.
     */

    public void setCompanyId(String companyId)
    {
        this.companyId = companyId;
    }

    /**
     * Returns the intacctImplementation.
     *
     * @return  with the intacctImplementation.
     */

    public IntacctFacade getIntacctImplementation()
    {
        return intacctImplementation;
    }

    /**
     * Sets the intacctImplementation.
     *
     * @param intacctImplementation  with the intacctImplementation.
     */

    public void setIntacctImplementation(IntacctFacade intacctImplementation)
    {
        this.intacctImplementation = intacctImplementation;
    }

    /**
     * Returns clientId.
     *
     * @return client id.
     */

    public String getClientId()
    {
        return clientId;
    }

    /**
     * Sets the clientId.
     *
     * @param clientId: client id.
     */

    public void setClientId(String clientId)
    {
        this.clientId = clientId;
    }

    /**
     * Returns locationId.
     *
     * @return location id.
     */

    public String getLocationId()
    {
        return locationId;
    }

    /**
     * Sets the locationId.
     *
     * @param clientId: client id.
     */

    public void setLocationId(String locationId)
    {
        this.locationId = locationId;
    }

    @SuppressWarnings("unchecked")
    private <T> List<T> coalesceList(List<T> list )
    {
        return (List<T>) ((list == null) ? Collections.emptyList() : list);
    }

    private Object nullifyEmptyListWrapper(final String propertyName,
                                       final List<Map<String, Object>> value,
                                       final Class<?> clazz)
    {
        if (clazz == null)
        {
            return null;
        }
        return mom.nullifyEmptyListWrapper(propertyName, value, clazz);
    }

    private Class<?> nullifyEnumType(Object enumType)
    {
        if (enumType == null)
        {
            return null;
        }
        return ((EnumType)enumType).getRequestType();
    }
}
